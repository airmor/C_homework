# gacha.h
``` cpp {.line-numbers}
#include "define_the_const.h"
#include "war.h"
#include "mainwindow.h"

#ifndef GACHA_H
#define GACHA_H
namespace cha {
    extern int cha[3];
    extern int coin;
    class gacha;
}
class cha::gacha
{
public:

    void cha_begin();//开始战斗
    int cha_buy(int num);//买,从左到右，从0开始计，第num个  //成功返回1，失败（钱不够等）返回0
    int cha_sell(int num);//卖队伍里从0开始第num个  //成功返回1，失败（钱不够等）返回0
    int cha_up();//升本 //成功返回1，失败（钱不够等）返回0
    int re();//重抽 //成功返回1，失败（钱不够等）返回0
};

#endif // GACHA_H
```
# gacha.cpp
``` cpp {.line-numbers}
#include "gacha.h"
#include "random"

namespace cha {
    int cha[3];
    int coin;

    //下面四个函数的用处见头文件。
    void gacha::cha_begin()
    {

    }

    int gacha::cha_buy(int num)
    {

    }

    int gacha::cha_sell(int num)
    {

    }

    int gacha::cha_up()
    {

    }

    int gacha::re()
    {

    }

}
```
# random.h
``` cpp {.line-numbers}
#include "define_the_const.h"

#ifndef RANDOM_H
#define RANDOM_H

#include <QMainWindow>


QT_BEGIN_NAMESPACE
namespace random{
    int xdy(int x,int y);
    int a_to_b(int a,int b);
}
QT_END_NAMESPACE



#endif // RANDOM_H
```
# random.cpp
``` cpp {.line-numbers}
#include "random.h"


namespace random {
    int xdy(int x,int y)//生成一个xdy的随机数
    {

    }
    int a_to_b(int a,int b)//生成一个>=a,<=b的随机数
    {

    }
}
```
# war.h
``` cpp {.line-numbers}
#include "define_the_const.h"

#ifndef WAR_H
#define WAR_H

#include <QMainWindow>

QT_BEGIN_NAMESPACE
namespace role {
struct enemy;
class enemy_change;
struct enemy_base;
struct role_base;
struct role_current;
struct team;
class skill;
class enemy_skill;
extern const struct role::role_base all_role_base[all_role_number];
extern struct role::team left_team;
extern struct enemy* root;
extern const struct role::enemy_base all_enemy_base[4];
}

namespace fight{
using namespace role;
struct fight_current;
class a_fight;
struct change;
}
QT_END_NAMESPACE

struct role::role_base//角色基本参数（常数）
{
    char name[20];
    int name_number;
    int level;
    int blood;
    int attack[2];
    int camp[2];
};

struct role::role_current//角色实时状态
{
    int name_number;//角色职业
    int blood;//实时血量
    float camp_influence;//阵营的影响
};

struct role::team
{
    int num;//队伍数量
    struct role::role_current each[max_of_a_team];//每个队员实时状态
};

struct role::enemy{
    int name;
    int level;
    int blood;
    struct role::enemy *next;
};

struct fight::fight_current{

};

class fight::a_fight{
public:
    static void tmp();
    static struct fight::change a_attack(int t);
    static void initialize_role();
};

struct fight::change{
    int left[6][2];
    //left[i][j]第一个数字代表是第i个角色数据有没有变化有为非1，没有为0，j表示变化,回血就是正的,扣血为负数
    int right[6][2];
};

class role::enemy_change{
public:
    void die(enemy_change* p);
    void add(int num);
};

struct role::enemy_base{
    char name[20];
    int name_number;
    int blood;
    int attack[2];
};

class role::skill{
    void skill0();
    void skill1();
    //………………
};

class role::enemy_skill{
    int zhanshi(int level);
    int fashi(int level);
    int sheshou(int level);
    int mushi(int level);
};


#endif // WAR_H
```
# war.cpp
``` cpp {.line-numbers}
#include <stdio.h>
#include "war.h"
#include "random"

namespace role {
const struct role_base all_role_base[all_role_number]={
    //all_role_nunber在头文件中改
    //name,name_number_blood,defence,attack,camp[2]
    //  \   0       1       2
    //  0守序善良|守序中立|守序邪恶
    //  1中立善良|绝对中立|中立邪恶
    //  2混乱善良|混乱中立|混乱邪恶     //阵营的影响怎么算想一下最后变成一个一位小数如0.9、1.1然后造成伤害的时候乘这个系数大于1代表有加成，小于一代表有负面影响。
    {"战士",0,1,15,{2,6},{1,1}},//1级 15血 攻击2d6 阵营绝对中立
    {"法师",1,1,15,{2,6},{1,1}},
    {"牧师",2,1,15,{2,6},{1,1}},
    {"射手",3,1,15,{2,6},{1,1}}//乱写的数据
};
const struct enemy_base all_enemy_base[4]={
    {"侏儒战士",0,15,{2,6}},
    {"侏儒法师",1,15,{2,6}},
    {"侏儒牧师",2,15,{2,6}},
    {"侏儒射手",3,15,{2,6}}
};
struct team left_team;
struct enemy* root;
}
using namespace role;

//这个是敌人的技能，返回造成的伤害，全局变量的改变在这里完成。
int role::enemy_skill::zhanshi(int level)
{

}

int role::enemy_skill::fashi(int level)
{

}

int role::enemy_skill::sheshou(int level)
{

}

int role::enemy_skill::mushi(int level)
{

}

void role::enemy_change::die(enemy_change* p) // 敌人用一个链表来管理,指针指向的敌人死亡
{

}

void role::enemy_change::add(int num) //生成一个链表的敌人,个数为num
{

}

void fight::a_fight::tmp()//测试用函数，无用可注释掉。
{

    role::left_team.num=4;
    role::left_team.each[0]={0,1,1.1};
    role::left_team.each[1]={1,1,1.1};
    role::left_team.each[2]={2,1,1.1};
    role::left_team.each[3]={3,1,1.1};
}

fight::change fight::a_fight::a_attack(int t)
//这个是你们要编写的主要函数,代表一次攻击t为0时是左边对右边发起一次攻击，t不是0的是右边对左边发起一次攻击；
//要改变全局变量struct team left_team和enemy* root（已经定义好了，内容看头文件，代表角色实时状态）
//还要将返回值fight::change类型（看头文件）的变量代表发生了什么变化（到时候有掉血和加血的动画）
//可以调用random里的函数生成随机数。要注意血量不要超过限制（小于0或大于最高血）
//技能调用skill类里的函数，还没有编
//注意没血的敌人会被删除，但是角色不会。所以这个函数要判断角色有没有血再攻击。同时没血也不占位置。
{
    fight::change all;

    return all;
}

void fight::a_fight::initialize_role()
//初始化角色吧struct team left_team（已经定义好了，内容看头文件，代表角色实时状态）初始化，同时计算阵营影响也在这一步
{

}
```
# mainwindow.h
``` cpp {.line-numbers}
#include "define_the_const.h"

#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QWidget>
#include<QMap>
#include<QList>
#include<QUrl>
#include<QTimer>
#include<QEvent>
#include<QMouseEvent>
#include<QContextMenuEvent>
#include<QMenu>

QT_BEGIN_NAMESPACE
namespace Ui {
extern float size;
class MainWindow;
class role_paint;
class light_paint;
struct LIGHT;
extern struct LIGHT light;
}

QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

protected:
    void paintEvent(QPaintEvent* event)override;
    void mousePressEvent(QMouseEvent *event)override;
    void keyPressEvent(QKeyEvent *event)override;
    void wheelEvent(QWheelEvent *event)override;

public:
    static int get_buttom(){
        return buttom;
    };

private:
    static int buttom;

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private:
    Ui::MainWindow *ui;
    Ui::role_paint *rolePaint;
    Ui::light_paint *lightPaint;

private:
    const QString backboard1="source/backboard.png";
    QString backboard=backboard1;
};


//role_paint
class Ui::role_paint : public QWidget
{
    Q_OBJECT

public:
    explicit role_paint(QWidget *parent = nullptr);  // 添加构造函数声明
    ~role_paint();

protected:
    void paintEvent(QPaintEvent* event)override;

private:
    int *role_path_l;
    QString path_role;
    QString path_card;

private:
    const int L_role_place[max_of_a_team][2]={{1135,548},{880,548},{632,548},{377,548},{5,548},{6,548}};
    const int R_role_place[max_of_a_team][2]={{1,1},{2,2},{3,3},{4,4},{5,5},{6,6}};
    const int L_card_place[max_of_a_team][2]={{1259,1145},{1069,1145},{878,1145},{688,1145},{496,1145},{305,1145}};
    const int R_card_place[max_of_a_team][2]={{1,1},{2,2},{3,3},{4,4},{5,5},{6,6}};
    const int place_to_card[num_of_attribute][2]={{80,250},{75,340},{80,420},{85,513}};
    const int card_pool_place[max_of_card_pool][2]={{1,1},{2,2},{3,3},{4,4},{5,5},{6,6}};

public:
    const char all_role_path[all_role_number][30]={
        "source/roles/zhanshi.png",
        "source/roles/fashi.png",
        "source/roles/mushi.png",
        "source/roles/sheshou.png"
    };
    const char all_card_path[all_role_number][40]={
        "source/roles/zhanshi_simple.png",
        "source/roles/fashi_simple.png",
        "source/roles/mushi_simple.png",
        "source/roles/sheshou_simple.png"
    };

};

class Ui::light_paint : public QWidget
{

public:
    explicit light_paint(QWidget *parent = nullptr);  // 添加构造函数声明
    ~light_paint();

protected:
    void paintEvent(QPaintEvent* event)override;

};

struct Ui::LIGHT{
    int* card_type;
};

#endif // MAINWINDOW_H
```
# mainwindow.cpp
``` cpp {.line-numbers}
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include<QPaintEvent>
#include<QPainter>//绘图
#include<QPixmap>//图片
//#include<QImage>
#include<QCursor>
#include<QMetaEnum>
#include "war.h"
#define role_wide 1
#define role_high 1
#define role_card_wide 1
#define role_card_high 1

namespace Ui {
float size=0.5;
struct LIGHT light;
}


void MainWindow::paintEvent(QPaintEvent *event)
{
    QPainter painter(this);

    if(!this->backboard.isEmpty()) {
        QPixmap pix;
        //QImage pix;
        // 直接加载资源路径

        if(pix.load(this->backboard)) {
            painter.drawPixmap(0, 0,3072*Ui::size,1836*Ui::size, pix);
        } else {
            qDebug() << "Failed to load pixmap:" << this->backboard;
        }
    }
}

void MainWindow::mousePressEvent(QMouseEvent *event)
{
    if(event->button()== Qt::MouseButton::LeftButton)
    {
        qDebug()<<"鼠标左键按下"<<":"<<event->pos();
        int x=event->pos().x();
        int y=event->pos().y();//二叉树搜索
        if(x>1 && x<2 && y>1 && y<2 ){

        }
    }
}

void MainWindow::keyPressEvent(QKeyEvent *event)
{
    qDebug()<<"按键按下";
    if(event->key()==Qt::Key_Left || event->key()==Qt::Key_A)
    {
        qDebug()<<"检测到Left/A按下";
    }
    if(event->key()==Qt::Key_Right || event->key()==Qt::Key_D)
    {
        qDebug()<<"检测到Righ/D按下";
    }
    if(event->key()==Qt::Key_Minus || event->key()==Qt::Key_Underscore)
    {
        qDebug()<<"检测到-/_按下";
        Ui::size*=0.9523809523809524;
        update();
        rolePaint->update();
        this->setFixedSize(3072*Ui::size,1836*Ui::size);
    }
    if(event->key()==Qt::Key_Plus || event->key()==Qt::Key_Equal)
    {
        qDebug()<<"检测到-/_按下";
        Ui::size*=1.05;
        update();
        rolePaint->update();
        this->setFixedSize(3072*Ui::size,1836*Ui::size);
    }
}

void MainWindow::wheelEvent(QWheelEvent *event)
{

}

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
    ,rolePaint(nullptr)
    ,lightPaint(nullptr)
{
    ui->setupUi(this);
    rolePaint = new Ui::role_paint(this);
    lightPaint = new Ui::light_paint(this);
    this->setFixedSize(3072*Ui::size,1836*Ui::size);
    fight::a_fight::tmp();
    update();
    rolePaint->update();
}

MainWindow::~MainWindow()
{
    delete ui;
}

Ui::role_paint::role_paint(QWidget *parent)
    : QWidget(parent)
    , role_path_l(nullptr)
{
    // 设置透明背景
    setAttribute(Qt::WA_TranslucentBackground);
    // 可选：设置固定大小
    setFixedSize(3072*Ui::size, 1836*Ui::size);
}

Ui::role_paint::~role_paint()
{
    // 释放动态分配的内存
    if (role_path_l != nullptr) {
        free(role_path_l);
        role_path_l
            = nullptr;
    }
}

void Ui::role_paint::paintEvent(QPaintEvent *event)
{
    role_path_l=(int *)malloc(role::left_team.num*sizeof(int));
    for(int i=0;i<role::left_team.num;i++){
        role_path_l[i]=role::left_team.each[i].name_number;
    }
    QPainter painter(this);

    for(int i=0;i<role::left_team.num;i++){
        if(role_path_l!=NULL){
            path_role=QString(all_role_path[role_path_l[i]]);
            path_card=QString(all_card_path[role_path_l[i]]);
        }
        else{
            break;
        }
        if(!this->path_role.isEmpty()) {
            //QPixmap pix;
            QImage pix;
            // 直接加载资源路径
            if(pix.load(this->path_role)) {
                // 水平翻转（左右翻折）
                QImage flippedImage = pix.flipped(Qt::Horizontal);

                // 转换为QPixmap绘制
                QPixmap flippedPixmap = QPixmap::fromImage(flippedImage);
                painter.drawPixmap(L_role_place[i][0]*Ui::size,L_role_place[i][1]*Ui::size,224*Ui::size,224*Ui::size, flippedPixmap);
            } else {
                qDebug() << "Failed to load pixmap:" << this->path_role;
            }
        }
        if(!this->path_card.isEmpty()) {
            QPixmap pix;
            //QImage pix;
            // 直接加载资源路径

            if(pix.load(this->path_card)) {
                painter.drawPixmap(L_card_place[i][0]*Ui::size,L_card_place[i][1]*Ui::size,187*Ui::size,567*Ui::size, pix);
                QFont font("Arial", 36*Ui::size, QFont::Bold);  // 字体名，大小，粗细
                // 或者逐个设置
                // font.setFamily("Arial");
                // font.setPointSize(36);
                // font.setBold(true);

                // 设置抗锯齿
                painter.setRenderHint(QPainter::Antialiasing);

                // 应用字体
                painter.setFont(font);

                // 设置白色画笔
                painter.setPen(Qt::white);

                // 绘制数字
                painter.drawText((L_card_place[i][0]+place_to_card[0][0])*Ui::size,(L_card_place[i][1]+place_to_card[0][1])*Ui::size, QString::number(role::left_team.each[i].blood));
                painter.drawText((L_card_place[i][0]+place_to_card[1][0])*Ui::size,(L_card_place[i][1]+place_to_card[1][1])*Ui::size, QString::number(role::all_role_base[role_path_l[i]].attack[0])+"d"+QString::number(role::all_role_base[role_path_l[i]].attack[1]));
                painter.drawText((L_card_place[i][0]+place_to_card[2][0])*Ui::size,(L_card_place[i][1]+place_to_card[2][1])*Ui::size, QString::number(role::all_role_base[role_path_l[i]].attack[0])+"d"+QString::number(role::all_role_base[role_path_l[i]].attack[1]));
                painter.drawText((L_card_place[i][0]+place_to_card[3][0])*Ui::size,(L_card_place[i][1]+place_to_card[3][1])*Ui::size, QString::number(role::left_team.each[i].camp_influence));
            } else {
                qDebug() << "Failed to load pixmap:" << this->path_card;
            }
        }
    }
}



Ui::light_paint::light_paint(QWidget *parent)
{

}

Ui::light_paint::~light_paint()
{

}

void Ui::light_paint::paintEvent(QPaintEvent *event)
{

}
```